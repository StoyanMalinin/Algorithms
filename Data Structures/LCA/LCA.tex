\documentclass[12pt]{article}
\usepackage{lingmacros}
\usepackage{tree-dvips}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsmath,amssymb}
\usepackage{multirow}
\usepackage{hyperref}
\usepackage{caption}

\usepackage{graphicx}
\graphicspath{ {./images/} }

\begin{document}
\title{Lowest Common Ancestor}
\date{}
\maketitle

\section*{Дефиниция и примери}
\subsection*{Дефиниция}
\paragraph*{}
Нека имаме кореново дърво $T$ с корен $root$. Връх $u$ се нарича предшественик на връх $v$, ако $u$ лежи на единствения път между $root$ и $v$. Ще бележим с $depth(u)$ дълбочината на връх $u$ или с други думи казано - разстоянието от $root$ до $u$. При тази конвенция, най-близкият общ предшественик на $u$ и $v$, който ще бележим с $lca(u, v)$, ще бъде върхът $x$ с максимална дълбочина, който е предшественик едновременно на $u$ и $v$. 
\subsection*{Примери}
\paragraph*{}
В този случай коренът е връх 1.

\begin{figure}[h]
\caption*{Фигура 1}
\centering
\includegraphics[width=0.5\textwidth]{tree1}
\end{figure}

\raggedright
\begin{itemize}
	\item $lca(5, 7) = 3$;
	\item $lca(4, 9) = 4$;
	\item $lca(3, 9) = 2$;
	\item $lca(2, 13) = 1$;
	\item $lca(4, 14) = 4$;
	\item $lca(2, 4) = 1$;
\end{itemize}

\section*{Свойства на lca(u, v)}
\begin{itemize}
	\item $lca(u, v) = lca(v, u)$
	\item $lca(u, v) = u$ тогава и само тогава, когато u e предшественик на $v$
	\item $lca(u, lca(v, w)) = lca(lca(u, v), w)$.
\paragraph*{}
По тази причина можем да записваме обобщено $lca(u, v, w)$. Това е полезно, ако например имаме нужда да пресмятаме $lca$ на цели интервали от масив. Поради това свойство знаем, че задачата има смисъл и може да се реши със сегментно дърво. От следващото свойство ще научим, че има и по-добър начин.
	\item $lca(u, v, v) = lca(u, v)$
\paragraph*{}
Това значи, че добавянето на "излишни" върхове към тези, на които търсим $lca$ не променя отговора. Тост ако искаме да сметнем $lca$ на група върхове можем да си ползволим да сметнем $lca$ на група, която съдържа тези върхове, но по няколко пъти. Това ни дава възможност да пресмятаме $lca$ на интервал от върхове чрез sparse table. Повече по темата ще научите по-късно.
	\item $lca(u, v) = lca(u, v')$, където $v'$ се получава, когато "качим" връх $v$ на нивото на връх $u$ (разбира се, приемаме, че $depth(u) \leq depth(v)$)
	\item $depth(lca(u, v)) \leq depth(u)$ и $depth(lca(u, v)) \leq v$.
\paragraph*{}
Можете да се убедите с примери от Фигура 1:
\begin{itemize}
	\item u = 5, v = 6, v' = 7
	\item u = 2, v = 13, v' = 3
	\item u = 11, v = 14, v' = 15
	\item u = 2, v = 9, v' = 2
\end{itemize} 
Тук ще покажем не съвсем формално доказателство на свойството. Ясно е, че след като само "покачваме" връхове то няма как $lca$ да "слезе". Затова само трябва да проверим, че $lca(u, v)$ е предшественик на $u$ и $v'$. Нека запишем $l = lca(u, v)$, тривиално е, че $l$ предшества $u$. Сега трябва да видим дали предшества $v'$. Допускаме противното: нека $l$ не предшества $v'$. Ние знаем, че $l$ предшества $v$. Тъй като ние само сме се качвали нагоре, то единственият вариант $l$ вече да не предшества $v'$ е да сме го "подминали", тоест $l$ да лежи на пътя между $v$ и $v'$. Ясно е също и че $l \neq v'$. Това обаче е противоречие, понеже $depth(l) \leq depth(u) = depth(v') \leq depth(v)$ и излиза, че няма как $l$ да лежи на пътя между $v$ и $v'$.
\end{itemize}

\section*{LCA с binary lifting}
\paragraph*{}
Използвайки тези свойства можем да изготвим алгоритъм, който намира $lca(u, v)$ за $O(logN)$. 
\paragraph*{}
Забелязваме, че ако имаме два върха $u$ и $v$ на равна дълбочина, то ако започнем постепенно да ги "качваме" едновременно, то стойностите ще се различават до един момомент и по-конкретно, първата стойност на съвпадение ще бъде точно $lca(u, v)$. Нека имаме функция $rise(u, n)$, която връща връх, отговарящ на връх $u$ след като бъде "качен" с $n$ стъпки. Тоест така излиза, че трябва да намерим най-малкото $n$, за което $rise(u, n) = rise(v, n)$ и тази стойност ще бъде $lca(u, v)$. По-късно обаче, ще стане ясно, че е по-добре да намерим последното $n$, за което $rise(u, n) \neq rise(v, n)$ и така $lca(u, n)$ ще бъде $parent(rise(u, n))$, където $paret(x)$ е родителят на $x$.
\paragraph*{}
От тези наблюдения става ясно, че е доста удобно да имаме бърз начин да "качваме" връхове. По тази причина е измислена техниката binary lifting. Идеята е следната: за всеки връх $x$ пазим $rise(x, 1)$, $rise(x, 2)$, $rise(x, 4)$, ..., $rise(x, 2^k)$, ... (разбира се няма нужда да пазим тези стойности до безкрай, а само до достатъчно голяма степен на 2). Ключовото наблюдение тук е, че тези стойности могат да се пресмятат доста лесно. Например: $rise(x, 1) = parent(x)$. Също така $rise(x, 2) = parent(parent(x)) = rise(rise(x, 1), 1)$. Забелязваме също и че: $rise(x, 2^k) = rise(rise(x, 2^{k-1}), 2^{k-1})$. Това е вярно, понеже искаме да направим $2^k$ стъпки нагоре, които можем да разделим на два скока по $2^{k-1}$. Разбира се, че ако се опитаме да скочим прекалено нагоре, няма да има връх в дървото, който да отговаря на този скок. Например $rise(2, 2)$ в дървото от Фигура 1 не съществува. Затова за такива случаи записваме, че стойността е $-1$. Също така приемаме, че $rise(-1, 2^k) = -1$.  

\end{document}